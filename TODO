
  * also abstract over recursive occurrences

    > type family Rep (t :: k) :: (k -> [*] -> *) -> [*] -> *

    > class Generic (t :: k) where
    >   toRep :: NLong (CountArgs k) ps =>
    >            W t ps -> Rep t W ps

    > class RMap (rep :: (k -> [*] -> *) -> [*] -> *) where
    >   rmap :: NLong (CountArgs k) ps =>
    >           (forall (t :: k) ps. r t ps -> r' t ps) ->
    >           rep r ps -> rep r' ps

 * generate indexed data types

   * does Idxd need to inline its own copy of QE?

   * cf "Enumerating Well-Typed Terms Generically" by Yakushev and Jeuring

 * modular use of EqFree

   * the SamesImplies approach seems to require compositionality (word choice?
     ... coinductiveness?) of NLong

     * ie: NLong (S n) (t ': ts) must imply NLong n ts

     * not sure how to establish this; closedness of Nat might help?

 * generic definition of EqFree

   * I suspect Idxd needs to simultaneously constraint all indices
